import { routes } from '@fleek-platform/utils-routes';
import { useCallback, useEffect, useState } from 'react';

import { constants } from '@/constants';
import { useAuthCookie } from '@/hooks/useAuthCookie';
import {
  AuthProviders,
  AuthWith,
  useAuthProviders,
} from '@/hooks/useAuthProviders';
import { usePostHog } from '@/hooks/usePostHog';
import { useRouter } from '@/hooks/useRouter';
import { createContext } from '@/utils/createContext';

import { useCookies } from './CookiesProvider';
import { clearUserSession } from '@/utils/clearUSerSession';

export type AuthContext = {
  loading: boolean;
  error?: unknown;
  token?: string;
  redirectUrl: string | null;

  login: (provider: AuthProviders, redirectUrl?: string) => void;
  logout: () => void;
  switchProjectAuth: (projectId: string) => Promise<void>;
  setRedirectUrl: React.Dispatch<React.SetStateAction<string | null>>;
};

const [Provider, useContext] = createContext<AuthContext>({
  name: 'AuthContext',
  hookName: 'useAuthContext',
  providerName: 'AuthProvider',
});

export const AuthProvider: React.FC<React.PropsWithChildren<{}>> = ({
  children,
}) => {
  const [accessToken, setAccessToken, clearAccessToken] = useAuthCookie();
  const posthog = usePostHog();
  const [redirectUrl, setRedirectUrl] = useState<string | null>(null);
  const cookies = useCookies();

  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<unknown>();

  const providers = useAuthProviders();
  const providersValues = Object.values(providers);
  const router = useRouter();

  const login = useCallback(
    (providerName: AuthProviders, redirectUrl?: string) => {
      if (redirectUrl) {
        setRedirectUrl(redirectUrl);
      }

      const provider = providers[providerName];
      provider.handleLogin();
    },
    [providers],
  );

  const logout = useCallback(async () => {
    const invitationHash = router.query.invitation;

    // TODO: Why would an invitation hash have to be
    // declared on logout? This might related to whitelisting
    // approach on persisting session state
    // see "clearUserSession" comment
    if (!constants.PUBLIC_ROUTES.includes(router.pathname.toLowerCase())) {
      await router.replace({
        pathname: routes.home(),
        query: invitationHash ? `invitation=${invitationHash}` : undefined,
      });
    }

    for (const provider of providersValues) {
      if (!provider.token) {
        // TODO: On "auth provider" initialisation
        // a name should be provided to help troubleshoot.
        // Include a name for each provider initialised.
        console.warn('Provider doesn\'t have a token or loogout callback');
        continue;
      }

      if (provider.token && typeof provider.handleLogout !== 'function') {
        // TODO: Name provider on initialisation
        // see related TODO above.
        console.warn('Provider doesn\'t have a logout callback');
        continue;
      }

      // TODO: For some reason the original author
      // hasn't awaited for the logout request.
      // This has to be revised as its possible
      // that there are asynchronous calls involved
      // which would have to be awaited for?
      await provider.handleLogout();
    }

    posthog.reset();

    // TODO: Session has third-party data
    // at time of writing there's no way to know which
    // values should persist. Use of a whitelist approach
    // can help. Until this is revised, all session data wiped
    clearUserSession();
  }, [cookies, clearAccessToken, router, providersValues]);

  const requestAccessToken = useCallback(
    async (provider: AuthWith, projectId?: string) => {
      if (loading) {
        return;
      }

      try {
        setLoading(true);
        setError(undefined);

        const token = await provider.requestAccessToken(projectId);
        setAccessToken(token);
      } catch (requestError) {
        logout();
        setError(requestError);
      } finally {
        setLoading(false);
      }
    },
    [setAccessToken, loading, logout],
  );

  const switchProjectAuth = useCallback(
    async (projectId: string) => {
      const provider = providersValues.find((provider) => provider.token);

      if (provider) {
        // if in site page, redirect to sites list first
        if (router.query.siteId) {
          await router.replace(routes.project.site.list({ projectId }));
          delete router.query.siteId;
        }

        return requestAccessToken(provider, projectId);
      }
    },

    // eslint-disable-next-line react-hooks/exhaustive-deps
    [providersValues, requestAccessToken],
  );

  useEffect(() => {
    const provider = providersValues.find((provider) => provider.token);

    if (provider?.token) {
      // if has a provider token, it means that auth provider is authenticated
      // TODO: If this is the token generated by dynamic
      // for the call to get the `accessToken`
      // if the token is valid, we seem to not have to need
      // dynamic for any purpose? Likewise, this doesn't
      // seem necessary.
      // cookies.set('authProviderToken', provider.token);

      const projectId =
        cookies.values.projectId || constants.DEFAULT_PROJECT_ID;

      // redirect if is in home page
      if (router.pathname === routes.home()) {
        // keep query on redirect
        router.push({
          pathname: routes.project.home({ projectId }),
          query: router.query,
        });
      }

      // redirect if has a redirect url pending
      if (redirectUrl) {
        router.push(redirectUrl.replace('[projectid]', projectId));

        setRedirectUrl(null);
      }

      // uses the auth provider token to request the access token from graphql
      if (!accessToken) {
        requestAccessToken(provider);
      }
    } else {
      logout();
    }

    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    cookies.values.authProviderToken,
    ...providersValues.map((provider) => provider.token),
  ]);

  return (
    <Provider
      value={{
        loading,
        error,
        login,
        logout,
        switchProjectAuth,
        token: accessToken,
        redirectUrl,
        setRedirectUrl,
      }}
    >
      {children}
    </Provider>
  );
};

export const useAuthContext = useContext;
